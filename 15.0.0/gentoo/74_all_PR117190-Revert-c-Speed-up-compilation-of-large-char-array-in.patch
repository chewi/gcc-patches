From ec2844301e40a017a32b4f11f499d6db7629c6bf Mon Sep 17 00:00:00 2001
Message-ID: <ec2844301e40a017a32b4f11f499d6db7629c6bf.1729247640.git.sam@gentoo.org>
In-Reply-To: <bfec21e6cf88b0b64bfcc30d2f5ae3b3370e36e3.1729247640.git.sam@gentoo.org>
References: <bfec21e6cf88b0b64bfcc30d2f5ae3b3370e36e3.1729247640.git.sam@gentoo.org>
From: Sam James <sam@gentoo.org>
Date: Fri, 18 Oct 2024 11:31:27 +0100
Subject: [PATCH 2/2] Revert "c: Speed up compilation of large char array
 initializers when not using #embed"

This reverts commit f9bac238840155e1539aa68daf1507ea63c9ed80.

Keep the testcase.

Bug: https://gcc.gnu.org/PR117190
---
 gcc/c/c-parser.cc | 118 ----------------------------------------------
 gcc/c/c-tree.h    |   1 -
 gcc/c/c-typeck.cc |  36 --------------
 3 files changed, 155 deletions(-)

diff --git a/gcc/c/c-parser.cc b/gcc/c/c-parser.cc
index e4381044e5cb..9518459a0a57 100644
--- a/gcc/c/c-parser.cc
+++ b/gcc/c/c-parser.cc
@@ -6507,125 +6507,7 @@ c_parser_initval (c_parser *parser, struct c_expr *after,
 					    (init.value))))
 	init = convert_lvalue_to_rvalue (loc, init, true, true, true);
     }
-  tree val = init.value;
   process_init_element (loc, init, false, braced_init_obstack);
-
-  /* Attempt to optimize large char array initializers into RAW_DATA_CST
-     to save compile time and memory even when not using #embed.  */
-  static unsigned vals_to_ignore;
-  if (vals_to_ignore)
-    /* If earlier call determined there is certain number of CPP_COMMA
-       CPP_NUMBER tokens with 0-255 int values, but not enough for
-       RAW_DATA_CST to be beneficial, don't try to check it again until
-       they are all parsed.  */
-    --vals_to_ignore;
-  else if (val
-	   && TREE_CODE (val) == INTEGER_CST
-	   && TREE_TYPE (val) == integer_type_node
-	   && c_parser_next_token_is (parser, CPP_COMMA))
-    if (unsigned int len = c_maybe_optimize_large_byte_initializer ())
-      {
-	char buf1[64];
-	unsigned int i;
-	gcc_checking_assert (len >= 64);
-	location_t last_loc = UNKNOWN_LOCATION;
-	for (i = 0; i < 64; ++i)
-	  {
-	    c_token *tok = c_parser_peek_nth_token_raw (parser, 1 + 2 * i);
-	    if (tok->type != CPP_COMMA)
-	      break;
-	    tok = c_parser_peek_nth_token_raw (parser, 2 + 2 * i);
-	    if (tok->type != CPP_NUMBER
-		|| TREE_CODE (tok->value) != INTEGER_CST
-		|| TREE_TYPE (tok->value) != integer_type_node
-		|| wi::neg_p (wi::to_wide (tok->value))
-		|| wi::to_widest (tok->value) > UCHAR_MAX)
-	      break;
-	    buf1[i] = (char) tree_to_uhwi (tok->value);
-	    if (i == 0)
-	      loc = tok->location;
-	    last_loc = tok->location;
-	  }
-	if (i < 64)
-	  {
-	    vals_to_ignore = i;
-	    return;
-	  }
-	c_token *tok = c_parser_peek_nth_token_raw (parser, 1 + 2 * i);
-	/* If 64 CPP_COMMA CPP_NUMBER pairs are followed by CPP_CLOSE_BRACE,
-	   punt if len is INT_MAX as that can mean this is a flexible array
-	   member and in that case we need one CPP_NUMBER afterwards
-	   (as guaranteed for CPP_EMBED).  */
-	if (tok->type == CPP_CLOSE_BRACE && len != INT_MAX)
-	  len = i;
-	else if (tok->type != CPP_COMMA)
-	  {
-	    vals_to_ignore = i;
-	    return;
-	  }
-	/* Ensure the STRING_CST fits into 128K.  */
-	unsigned int max_len = 131072 - offsetof (struct tree_string, str) - 1;
-	unsigned int orig_len = len;
-	unsigned int off = 0, last = 0;
-	if (!wi::neg_p (wi::to_wide (val)) && wi::to_widest (val) <= UCHAR_MAX)
-	  off = 1;
-	len = MIN (len, max_len - off);
-	char *buf2 = XNEWVEC (char, len + off);
-	if (off)
-	  buf2[0] = (char) tree_to_uhwi (val);
-	memcpy (buf2 + off, buf1, i);
-	for (unsigned int j = 0; j < i; ++j)
-	  {
-	    c_parser_peek_token (parser);
-	    c_parser_consume_token (parser);
-	    c_parser_peek_token (parser);
-	    c_parser_consume_token (parser);
-	  }
-	for (; i < len; ++i)
-	  {
-	    if (!c_parser_next_token_is (parser, CPP_COMMA))
-	      break;
-	    tok = c_parser_peek_2nd_token (parser);
-	    if (tok->type != CPP_NUMBER
-		|| TREE_CODE (tok->value) != INTEGER_CST
-		|| TREE_TYPE (tok->value) != integer_type_node
-		|| wi::neg_p (wi::to_wide (tok->value))
-		|| wi::to_widest (tok->value) > UCHAR_MAX)
-	      break;
-	    c_token *tok2 = c_parser_peek_nth_token (parser, 3);
-	    if (tok2->type != CPP_COMMA && tok2->type != CPP_CLOSE_BRACE)
-	      break;
-	    buf2[i + off] = (char) tree_to_uhwi (tok->value);
-	    /* If orig_len is INT_MAX, this can be flexible array member and
-	       in that case we need to ensure another element which
-	       for CPP_EMBED is normally guaranteed after it.  Include
-	       that byte in the RAW_DATA_OWNER though, so it can be optimized
-	       later.  */
-	    if (tok2->type == CPP_CLOSE_BRACE && orig_len == INT_MAX)
-	      {
-		last = 1;
-		break;
-	      }
-	    last_loc = tok->location;
-	    c_parser_consume_token (parser);
-	    c_parser_consume_token (parser);
-	  }
-	val = make_node (RAW_DATA_CST);
-	TREE_TYPE (val) = integer_type_node;
-	RAW_DATA_LENGTH (val) = i;
-	tree owner = build_string (i + off + last, buf2);
-	XDELETEVEC (buf2);
-	TREE_TYPE (owner) = build_array_type_nelts (unsigned_char_type_node,
-						    i + off + last);
-	RAW_DATA_OWNER (val) = owner;
-	RAW_DATA_POINTER (val) = TREE_STRING_POINTER (owner) + off;
-	init.value = val;
-	set_c_expr_source_range (&init, loc, last_loc);
-	init.original_code = RAW_DATA_CST;
-	init.original_type = integer_type_node;
-	init.m_decimal = 0;
-	process_init_element (loc, init, false, braced_init_obstack);
-      }
 }
 
 /* Parse a compound statement (possibly a function body) (C90 6.6.2,
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
index bfdcb78bbcc1..e23d8e59ac4b 100644
--- a/gcc/c/c-tree.h
+++ b/gcc/c/c-tree.h
@@ -832,7 +832,6 @@ extern struct c_expr pop_init_level (location_t, int, struct obstack *,
 				     location_t);
 extern void set_init_index (location_t, tree, tree, struct obstack *);
 extern void set_init_label (location_t, tree, location_t, struct obstack *);
-unsigned c_maybe_optimize_large_byte_initializer (void);
 extern void process_init_element (location_t, struct c_expr, bool,
 				  struct obstack *);
 extern tree build_compound_literal (location_t, tree, tree, bool,
diff --git a/gcc/c/c-typeck.cc b/gcc/c/c-typeck.cc
index 108ea5ca3e8c..36d0b23a3d72 100644
--- a/gcc/c/c-typeck.cc
+++ b/gcc/c/c-typeck.cc
@@ -11347,42 +11347,6 @@ maybe_split_raw_data (tree value, tree *raw_data)
   return value;
 }
 
-/* Return non-zero if c_parser_initval should attempt to optimize
-   large initializers into RAW_DATA_CST.  In that case return how
-   many elements to optimize at most.  */
-
-unsigned
-c_maybe_optimize_large_byte_initializer (void)
-{
-  if (!constructor_type
-      || TREE_CODE (constructor_type) != ARRAY_TYPE
-      || constructor_stack->implicit)
-    return 0;
-  tree elttype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));
-  if (TREE_CODE (elttype) != INTEGER_TYPE
-      && TREE_CODE (elttype) != BITINT_TYPE)
-    return 0;
-  if (TYPE_PRECISION (elttype) != CHAR_BIT
-      || constructor_stack->replacement_value.value
-      || (COMPLETE_TYPE_P (constructor_type)
-	  && !poly_int_tree_p (TYPE_SIZE (constructor_type)))
-      || constructor_range_stack)
-    return 0;
-  if (constructor_max_index == NULL_TREE)
-    return INT_MAX;
-  if (tree_int_cst_le (constructor_max_index, constructor_index)
-      || integer_all_onesp (constructor_max_index))
-    return 0;
-  widest_int w = wi::to_widest (constructor_max_index);
-  w -= wi::to_widest (constructor_index);
-  w += 1;
-  if (w < 64)
-    return 0;
-  if (w > INT_MAX)
-    return INT_MAX;
-  return w.to_uhwi ();
-}
-
 /* Add one non-braced element to the current constructor level.
    This adjusts the current position within the constructor's type.
    This may also start or terminate implicit levels
-- 
2.47.0

