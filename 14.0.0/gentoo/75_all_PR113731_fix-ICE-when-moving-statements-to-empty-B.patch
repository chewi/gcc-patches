From c22a0c0ca1a5c31d107f90efd2221eb8bc198205 Mon Sep 17 00:00:00 2001
From: Tamar Christina <tamar.christina@arm.com>
Date: Wed, 7 Feb 2024 10:58:25 +0000
Subject: [PATCH 1/3] middle-end: fix ICE when moving statements to empty BB
 [PR113731]

We use gsi_move_before (&stmt_gsi, &dest_gsi); to request that the new statement
be placed before any other statement.  Typically this then moves the current
pointer to be after the statement we just inserted.

However it looks like when the BB is empty, this does not happen and the CUR
pointer stays NULL.   There's a comment in the source of gsi_insert_before that
explains:

/* If CUR is NULL, we link at the end of the sequence (this case happens

This adds a default parameter to gsi_move_before to allow us to control where
the insertion happens.

gcc/ChangeLog:

	PR tree-optimization/113731
	* gimple-iterator.cc (gsi_move_before): Take new parameter for update
	method.
	* gimple-iterator.h (gsi_move_before): Default new param to
	GSI_SAME_STMT.
	* tree-vect-loop.cc (move_early_exit_stmts): Call gsi_move_before with
	GSI_NEW_STMT.

gcc/testsuite/ChangeLog:

	PR tree-optimization/113731
	* gcc.dg/vect/vect-early-break_111-pr113731.c: New test.

(cherry picked from commit 8f6ed71d8fff3c3c6249651a72aee084e31ffb9e)
---
 gcc/gimple-iterator.cc                        |  7 +++---
 gcc/gimple-iterator.h                         |  3 ++-
 .../vect/vect-early-break_111-pr113731.c      | 22 +++++++++++++++++++
 gcc/tree-vect-loop.cc                         |  3 +--
 4 files changed, 29 insertions(+), 6 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/vect/vect-early-break_111-pr113731.c

diff --git a/gcc/gimple-iterator.cc b/gcc/gimple-iterator.cc
index 517c53376f05..55ef3198c52b 100644
--- a/gcc/gimple-iterator.cc
+++ b/gcc/gimple-iterator.cc
@@ -666,10 +666,11 @@ gsi_move_after (gimple_stmt_iterator *from, gimple_stmt_iterator *to)
 
 
 /* Move the statement at FROM so it comes right before the statement
-   at TO.  */
+   at TO using method M.  M defaults to GSI_SAME_STMT.  */
 
 void
-gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to)
+gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to,
+		 gsi_iterator_update m)
 {
   gimple *stmt = gsi_stmt (*from);
   gsi_remove (from, false);
@@ -677,7 +678,7 @@ gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to)
   /* For consistency with gsi_move_after, it might be better to have
      GSI_NEW_STMT here; however, that breaks several places that expect
      that TO does not change.  */
-  gsi_insert_before (to, stmt, GSI_SAME_STMT);
+  gsi_insert_before (to, stmt, m);
 }
 
 
diff --git a/gcc/gimple-iterator.h b/gcc/gimple-iterator.h
index 2e83a9660efc..78014a43cb93 100644
--- a/gcc/gimple-iterator.h
+++ b/gcc/gimple-iterator.h
@@ -86,7 +86,8 @@ extern gimple_stmt_iterator gsi_for_stmt (gimple *);
 extern gimple_stmt_iterator gsi_for_stmt (gimple *, gimple_seq *);
 extern gphi_iterator gsi_for_phi (gphi *);
 extern void gsi_move_after (gimple_stmt_iterator *, gimple_stmt_iterator *);
-extern void gsi_move_before (gimple_stmt_iterator *, gimple_stmt_iterator *);
+extern void gsi_move_before (gimple_stmt_iterator *, gimple_stmt_iterator *,
+			     gsi_iterator_update = GSI_SAME_STMT);
 extern void gsi_move_to_bb_end (gimple_stmt_iterator *, basic_block);
 extern void gsi_insert_on_edge (edge, gimple *);
 extern void gsi_insert_seq_on_edge (edge, gimple_seq);
diff --git a/gcc/testsuite/gcc.dg/vect/vect-early-break_111-pr113731.c b/gcc/testsuite/gcc.dg/vect/vect-early-break_111-pr113731.c
new file mode 100644
index 000000000000..b205f470660a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/vect-early-break_111-pr113731.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-add-options vect_early_break } */
+/* { dg-require-effective-target vect_early_break } */
+/* { dg-require-effective-target vect_long } */
+/* { dg-additional-options "-msse4.2" { target i?86-*-* x86_64-*-* } } */
+
+/* { dg-final { scan-tree-dump "LOOP VECTORIZED" "vect" } } */
+
+char* inet_net_pton_ipv4_bits;
+char inet_net_pton_ipv4_odst;
+void __errno_location();
+void inet_net_pton_ipv4();
+void inet_net_pton() { inet_net_pton_ipv4(); }
+void inet_net_pton_ipv4(char *dst, int size) {
+  while ((inet_net_pton_ipv4_bits > dst) & inet_net_pton_ipv4_odst) {
+    if (size-- <= 0)
+      goto emsgsize;
+    *dst++ = '\0';
+  }
+emsgsize:
+  __errno_location();
+}
diff --git a/gcc/tree-vect-loop.cc b/gcc/tree-vect-loop.cc
index 30b90d99925b..9aba94bd6ca2 100644
--- a/gcc/tree-vect-loop.cc
+++ b/gcc/tree-vect-loop.cc
@@ -11800,8 +11800,7 @@ move_early_exit_stmts (loop_vec_info loop_vinfo)
 	dump_printf_loc (MSG_NOTE, vect_location, "moving stmt %G", stmt);
 
       gimple_stmt_iterator stmt_gsi = gsi_for_stmt (stmt);
-      gsi_move_before (&stmt_gsi, &dest_gsi);
-      gsi_prev (&dest_gsi);
+      gsi_move_before (&stmt_gsi, &dest_gsi, GSI_NEW_STMT);
     }
 
   /* Update all the stmts with their new reaching VUSES.  */
-- 
2.43.0

